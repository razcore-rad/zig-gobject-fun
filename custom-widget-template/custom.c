/* What this is, is an extremely simple annotated .c file that implements a
 * custom widget in gtk3 with gobject. All it does is subclasses GtkDrawingArea
 * and creates a blank widget. 
 *
 * Requires: glib >= 2.44
 *
 * This is a template for a FINAL (as opposed to DERIVABLE gobject type.
 * Final types are simpler. You do most of the work in the C file and just
 * expose a handful of public methods in the .h file.
 *
 * In other words, as it can't be subclassed further, you don't publicly
 * expose the guts of the object at all and it's just all defined and dealt
 * with using standard GObject/GTK functions.
 */

/* First, we include our header file. See the annotations therein for more
 * information. */

#include "custom.h"

/* First, create the main struct that has the guts of the object in it.
 * It must follow this template in the tag; otherwise it won't be recognized
 * by the gobject macros.
 */

struct _DemoWidget {
	/* subclass type - be sure you do *not* use a pointer. Keep this as the
	 * first member. */
	GtkDrawingArea parent_instance;

	/* custom meat & potatoes go here. Eg: */
	// GtkWidget *button;
	// GtkWidget *entry;
};

/* once the main struct is defined as above, here is hte next macro. Make sure
 * this goes in before doing anything else. Order matters.
 *
 * First two arguments to the macro are boilerplate. The last is the standard
 * capitalized TYPE macro of *what you're subclassing.* Lowest you can go is
 * G_TYPE_OBJECT for a raw gobject. In this case we're subclassing
 * GtkDrawingArea, so that type macro is specified below.
 */

G_DEFINE_TYPE(DemoWidget, demo_widget, GTK_TYPE_DRAWING_AREA)

/* this function is used to build the widget. Note that although the docs refer
 * to something as the 'instance_init' function, the subroutine is actually
 * named *_init and not *_instance_init. That confused me at first.
 */

static void
demo_widget_init(DemoWidget *self) {
	/* Initialize anything needed here. Eg: */
	// self->button = gtk_button_new(...);
}

/* This is one stage of the destructor process along with _finalize.
 * Here, you more-so destruct items that have a `self` attached, as
 * opposed to being independent.
 *
 * See also:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 */

static void demo_widget_dispose(GObject *object) {
	DemoWidget *self = DEMO_WIDGET(object);

	/* Boilerplate:
	 * this is called `chaining up' by the gobject docs. *_parent_class
	 * is auto-generated by the macros - acc. to gtype.h, it's a static
	 * variable pointing to the parent class.
	 */
	G_OBJECT_CLASS(demo_widget_parent_class)->dispose(object);
}

/* Another stage of the destruction process. My understanding is that here,
 * you free items that are independent only; for things that have a reference to
 * 'self', you use dispose.
 *
 * See:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for a description of the nuances.
 */

static void demo_widget_finalize(GObject *gobject) {
	/* here, you would free stuff. I've got nuthin' for ya. */

	/* --- */

	/* Always chain up to the parent class; as with dispose(), finalize() is
	 * autogenerated and thus always guaranteed to exist on the parent's class
	 * virtual function table
	 */
	
	G_OBJECT_CLASS(demo_widget_parent_class)->finalize(gobject);
}

/* this subroutine gets run the first time the class is *ever* utilized but not
 * again.
 *
 * See:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for more info on what you need to put in this subroutine re: destructors.
 *
 * Note: I kept getting confused about what 'klass' meant and why it's spelled
 * that way. You could call it fluffy if you'd like - but it is just to avoid
 * using the token `class' on its own which is a c++ reserved word.
 */

static void demo_widget_class_init(DemoWidgetClass *klass) {
	/* <boilerplate> */
	GObjectClass *object_class = G_OBJECT_CLASS(klass);

	object_class->dispose = demo_widget_dispose;
	object_class->finalize = demo_widget_finalize;
	/* </boilerplate> */
}

/* and finally, here's the actual definition of our public function to create
 * an instance of our object which is... completely boilerplate!
 */

GtkWidget *demo_widget_new(void) {
	return g_object_new(DEMO_TYPE_WIDGET, NULL);
}
