// vim: colorcolumn=80 ts=4 sw=4

#include "demowidget.h"

/* GLOBALS FOR PROPERTIES */

enum property_types
{
	PROP_LABEL = 1,
	N_PROPERTIES
};

static GParamSpec *properties[N_PROPERTIES];

/* GLOBALS FOR SIGNALS */

enum signal_types {
	TOGGLED,
	LAST_SIGNAL
};

static guint signals[LAST_SIGNAL];

/* INTERNAL DECLARATIONS */

/* destructors - these are not generated by the macros automatically. */

static void demo_widget_dispose (GObject *object);
static void demo_widget_finalize (GObject *object);

/* GOBJECT DEFINITION */

struct _DemoWidget
{
	GtkWidget parent_instance;

	char *label;
	PangoLayout *layout;
	GdkRectangle layout_rect;
	gboolean label_selected;
	GtkGesture *gesture;
};

G_DEFINE_TYPE (DemoWidget, demo_widget, GTK_TYPE_WIDGET)


/* PRIVATE INTERNAL FUNCTIONS */

/* Properties - Getters and Setters */

static void
demo_widget_set_property (GObject *object,
		guint property_id,
		const GValue *value,
		GParamSpec *pspec)
{
	DemoWidget *self = DEMO_WIDGET(object);

	switch (property_id)
	{
		case PROP_LABEL:
			demo_widget_set_label (self, g_value_get_string (value));
			break;

		default:
			/* We don't have any other property... */
			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
			break;
	}
}

static void
demo_widget_get_property (GObject *object,
		guint property_id,
		GValue *value,
		GParamSpec *pspec)
{
	DemoWidget *self = DEMO_WIDGET(object);

	switch (property_id)
	{
		case PROP_LABEL:
			g_value_set_string (value, demo_widget_get_label (self));
			break;

		default:
			/* We don't have any other property... */
			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
			break;
	}
}

/* _snapshot helper function */
static void
render_highlights (DemoWidget *self,
		GtkSnapshot *snapshot)
{
	GtkStyleContext *context;
	graphene_rect_t grect;

	context = gtk_widget_get_style_context (GTK_WIDGET(self));
	grect = GRAPHENE_RECT_INIT (
			self->layout_rect.x,
			self->layout_rect.y,
			self->layout_rect.width,
			self->layout_rect.height);

	gtk_style_context_save (context);
	gtk_style_context_set_state (context, GTK_STATE_FLAG_SELECTED);
	gtk_snapshot_push_clip (snapshot, &grect);
	gtk_snapshot_render_background (snapshot, context,
			self->layout_rect.x,
			self->layout_rect.y,
			graphene_rect_get_width (&grect),
			graphene_rect_get_height (&grect));
	gtk_snapshot_render_layout (snapshot, context,
			self->layout_rect.x,
			self->layout_rect.y,
			self->layout);
	gtk_snapshot_pop (snapshot);
	gtk_style_context_restore (context);
}

static void
demo_widget_snapshot (GtkWidget *widget, GtkSnapshot *snapshot)
{
	DemoWidget *self = DEMO_WIDGET(widget);

	/* Style/CSS feeder object */
	GtkCssProvider *provider;
	/* Style metadata */
	GtkStyleContext *context;
	/* Same as a GdkRectangle; struct of ints: { x, y, width, height } */
	GtkAllocation allocation;

	context = gtk_widget_get_style_context (widget);
	gtk_style_context_add_class (context, "view");

	provider = gtk_css_provider_new ();

	gtk_css_provider_load_from_data (provider,
			"#demowidget {\n"
			"  border: 5px solid red;\n"
			"}\n",
			-1);

	gtk_style_context_add_provider (context,
			GTK_STYLE_PROVIDER(provider),
			GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);

	gtk_widget_get_allocation (widget, &allocation);

	/* ------------------------------ */
	/* Draw our background and layout */
	/* ------------------------------ */

	gtk_snapshot_render_background (snapshot, context,
			/* double x, */			allocation.x,
			/* double y, */			allocation.y,
			/* double width, */		allocation.width,
			/* double height */		allocation.height);

	gtk_snapshot_render_layout (snapshot, context,
			/* double x, */			allocation.x,
			/* double y, */			allocation.y,
			self->layout);

	if (self->label_selected)
		render_highlights (self, snapshot);
}

/* Callbacks */

static void
gesture_released_cb (GtkGestureClick *gesture,
		int n_press,
		double x,
		double y,
		gpointer user_data)
{
	DemoWidget *self = DEMO_WIDGET(user_data);

	if (x <= self->layout_rect.width && y <= self->layout_rect.height)
	{
		demo_widget_toggle_selection (self);
	}
}

/* CONSTRUCTORS AND DESTRUCTORS */

static void
demo_widget_init (DemoWidget *self)
{
	GtkWidget *widget = GTK_WIDGET(self);
	
	gtk_widget_set_name (widget, "demowidget");

	/* Pango layout for text rendering */
	self->layout = gtk_widget_create_pango_layout (widget, NULL);

	/* Setup gesture */
	self->gesture = gtk_gesture_click_new ();
	g_signal_connect (self->gesture, "released",
			G_CALLBACK(gesture_released_cb), self);
	gtk_widget_add_controller (widget, GTK_EVENT_CONTROLLER(self->gesture));
}

static void
demo_widget_dispose (GObject *object)
{
	DemoWidget *self = DEMO_WIDGET(object);

	/* nb: no need to destroy the GtkEventController (ie Gesture) according
	 * to TFM. */

	/* Final step: Chain up */

	G_OBJECT_CLASS(demo_widget_parent_class)->dispose(object);
}

static void
demo_widget_finalize (GObject *object)
{
	DemoWidget *self = DEMO_WIDGET(object);

	g_clear_pointer (&self->label, g_free);

	/* Always chain up to the parent class; as with dispose(), finalize() is
	 * autogenerated and thus always guaranteed to exist on the parent's class
	 * virtual function table
	 */
	
	G_OBJECT_CLASS(demo_widget_parent_class)->finalize(object);
}

static void
demo_widget_class_init (DemoWidgetClass *klass)
{
	GObjectClass *object_class = G_OBJECT_CLASS(klass);
	GtkWidgetClass *widget_class = GTK_WIDGET_CLASS(klass);
	GParamFlags default_flags =
		G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_EXPLICIT_NOTIFY;

	/* map vfuncs */

	object_class->dispose = demo_widget_dispose;
	object_class->finalize = demo_widget_finalize;
	object_class->set_property = demo_widget_set_property;
	object_class->get_property = demo_widget_get_property;

	widget_class->snapshot = demo_widget_snapshot;

	/* properties */

	properties[PROP_LABEL] = g_param_spec_string ("label",
			"Button label",
			"Textual label for our lovely button",
			/* default: */	"Hello, world!",
			default_flags);

	g_object_class_install_properties (object_class, N_PROPERTIES, properties);

	/* signals */

	signals[TOGGLED] = g_signal_new_class_handler ("toggled",
			G_OBJECT_CLASS_TYPE (object_class),
			G_SIGNAL_RUN_LAST,
		/* no default C function */
			NULL,
		/* defaults for accumulator, marshaller &c. */
			NULL, NULL, NULL,	
		/* No return type or params. */
			G_TYPE_NONE, 0);

	/* layout manager */

	gtk_widget_class_set_layout_manager_type (GTK_WIDGET_CLASS(klass),
			GTK_TYPE_BOX_LAYOUT);
}

/* PUBLIC METHOD DEFINITIONS */

void
demo_widget_set_label (DemoWidget *self, const char *label)
{
	/* docs aren't clear whether these will be set to 0 by
	 * pango_layout_get_size in the event the function fails */
	int label_width = 0, label_height = 0;

	/* Set our object's label variable, freeing if necessary */
	g_clear_pointer (&self->label, g_free);
	self->label = g_strdup (label);

	/* Update pango layout accordingly */
	pango_layout_set_text (self->layout, self->label, -1);
	pango_layout_get_size (self->layout, &label_width, &label_height);
	self->layout_rect.width = label_width / PANGO_SCALE;
	self->layout_rect.height = label_height / PANGO_SCALE;

	gtk_widget_queue_draw (GTK_WIDGET(self));

	g_object_notify_by_pspec (G_OBJECT(self), properties[PROP_LABEL]);
}

const char *
demo_widget_get_label (DemoWidget *self)
{
	return self->label;
}

void
demo_widget_toggle_selection (DemoWidget *self)
{
	self->label_selected = self->label_selected ? FALSE : TRUE;
	gtk_widget_queue_draw (GTK_WIDGET(self));
	g_signal_emit (self, signals[TOGGLED], 0);
}

GtkWidget *
demo_widget_new (void)
{
	return g_object_new (DEMO_TYPE_WIDGET, NULL);
}
