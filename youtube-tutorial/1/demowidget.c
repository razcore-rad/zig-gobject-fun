// vim: colorcolumn=80 ts=4 sw=4

/* This is an extremely simple annotated .c file that implements a custom
 * widget in gtk4 with gobject. All it does is subclasses GtkWidget and creates
 * a widget which is just a button. 
 *
 * Requires: glib >= 2.44, gtk4 >= 4.0.0 
 *
 * This is a template for a FINAL (as opposed to DERIVABLE gobject type.
 * Final types are simpler. You do most of the work in the C file and just
 * expose a handful of public methods in the .h file.
 *
 * In other words, as it can't be subclassed further, you don't publicly
 * expose the guts of the object at all and it's just all defined and dealt
 * with using standard GObject/GTK functions.
 */

#include "demowidget.h"

/* INTERNAL DECLARATIONS */

/* This is not strictly necessary as we've kept things in a naturally working
 * order below. But G_DEFINE_TYPE does *not* provide declarations for these
 * destructor functions, so if you change the order of the constructors and
 * destructors defined below, you'll get an error.
 */

static void demo_widget_dispose (GObject *object);
static void demo_widget_finalize (GObject *object);

/* GOBJECT DEFINITION */

/* First, create the main struct that has the guts of the object in it.
 * Follow the format of the underscore followed by the CamelCase type
 * name that you created in the header file. The typedef is autogenerated
 * by the macros and is expected to be defined here.
 */

struct _DemoWidget
{
	/* subclass type - be sure you do *not* use a pointer. Keep this as the
	 * first member.
	 */
	GtkWidget parent_instance;

	/* Custom meat and potatoes go here. For now, we are just creating a
	 * button. Here, you *do* use pointers when you want to incorporate other
	 * objects in the structure.
	 */
	GtkWidget *button;
};

/* once the main struct is defined as above, here is the next macro. Make sure
 * this goes in before doing anything else. Order matters.
 *
 * First two arguments to the macro are boilerplate. The last is the standard
 * capitalized TYPE macro of *what you're subclassing.* Lowest you can go is
 * G_TYPE_OBJECT for a raw gobject. In this case we're subclassing
 * GtkWidget, so that type macro is specified below.
 */
G_DEFINE_TYPE (DemoWidget, demo_widget, GTK_TYPE_WIDGET)


/* METHOD DEFINITIONS */

/* this function is used to build the widget. Note that although the docs refer
 * to something as the 'instance_init' function, the subroutine is actually
 * named *_init and not *_instance_init. That confused me at first.
 */
static void
demo_widget_init (DemoWidget *self)
{
	/* Not necessary, but it is a useful shorthand. */
	GtkWidget *widget = GTK_WIDGET(self);

	self->button = gtk_button_new_with_label ("Hello, world!");
	gtk_widget_set_hexpand (self->button, TRUE);
	gtk_widget_set_parent (self->button, widget);
}

/* This is one stage of the destructor process along with _finalize.
 * Here, you mostly destruct items that are reference-counted (eg, GObject-y
 * stuff) as opposed to not (like a string, or a FILE * pointer, which should
 * be freed / fclosed as opposed to being unreffed).
 *
 * It is important to remember this method may be called multiple times. It
 * is a programmer error not to account for that. If you unref a GObject that
 * already has a reference count of 0, you'll get a runtime error. See below
 * for how we account for that.
 *
 * See Part 1B of this series for problems you can run into if you don't deal
 * with this correctly.
 *
 * See also:
 * https://developer-old.gnome.org/gobject/stable/howto-gobject-destruction.html
 */
static void
demo_widget_dispose (GObject *object)
{
	DemoWidget *self = DEMO_WIDGET(object);

	/* g_clear_pointer is a very useful function. It calls a function of your
	 * choice to unref or free a pointer, and then sets that pointer to NULL.
	 * If it is called on a NULL pointer, it simply does nothing. That allows
	 * for a perfect way to handle the issue of _dispose being called multiple
	 * times.
	 *
	 * Here, gtk_widget_unparent is the standard GTK function to de-couple
	 * a child widget from its parent, which unrefs that widget behind the
	 * scenes.
	 *
	 * Note that g_clear_pointer takes a pointer *to* a gpointer, and not a
	 * straight gpointer. That is necessary for the function to NULL-ify the
	 * pointer.
	 */
	g_clear_pointer (&self->button, gtk_widget_unparent);

	/* Final step: Chain up (boilerplate)
	 *
	 * This is called `chaining up' by the gobject docs. *_parent_class
	 * is auto-generated by the macros - acc. to gtype.h, it's a static
	 * variable pointing to the parent class.
	 */
	G_OBJECT_CLASS(demo_widget_parent_class)->dispose (object);
}

/* Second and final stage of the destruction process. See _finalize above for
 * more info. We don't have anything to put in here yet, but we include it for
 * posterity and for easy addition later; so we just manually chain up for now.
 */
static void
demo_widget_finalize (GObject *object)
{
	/* --- */

	/* Always chain up to the parent class; as with dispose(), finalize() is
	 * autogenerated and thus always guaranteed to exist on the parent's class
	 * virtual function table
	 */
	G_OBJECT_CLASS(demo_widget_parent_class)->finalize(object);
}

/* this method gets run the first time the class is *ever* utilized but not
 * again.
 *
 * See:
 * https://developer-old.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for more info on what you need to put in this subroutine re: destructors.
 *
 * Note: I kept getting confused about what 'klass' meant and why it's spelled
 * that way. It is just to avoid using the token 'class' on its own which is a
 * c++ reserved word. You could call it something else like 'gclass' if you'd
 * like, but it has idiomatically been called 'klass' for 20+ years, so it's
 * probably best to just stick with that.
 */
static void
demo_widget_class_init (DemoWidgetClass *klass)
{
	/* Establish a shorthand to avoid some casts. */
	GObjectClass *object_class = G_OBJECT_CLASS(klass);

	/* Map the dispose and finalize 'virtual functions' to the functions
	 * we defined above.
	 */
	object_class->dispose = demo_widget_dispose;
	object_class->finalize = demo_widget_finalize;

	/* Tell our widget which type of 'layout manager' to use so it knows
	 * how to arrange the widgets. Box type is a good default.
	 */
	gtk_widget_class_set_layout_manager_type (GTK_WIDGET_CLASS(klass),
			GTK_TYPE_BOX_LAYOUT);
}

/* and finally, here's the actual definition of our public function to create
 * an instance of our object.
 *
 * It takes the GType of the GObject type, followed (optionally) by name/value
 * pairs to set object 'properties', followed by NULL when you're done. Since
 * we don't have any properties we're going to instantiate, we just pass NULL
 * after the GType. We'll discuss GObject properties later on.
 */
GtkWidget *
demo_widget_new (void)
{
	return g_object_new (DEMO_TYPE_WIDGET, NULL);
}
