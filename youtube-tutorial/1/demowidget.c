// vim: colorcolumn=80 ts=4 sw=4

/* What this is, is an extremely simple annotated .c file that implements a
 * custom widget in gtk4 with gobject. All it does is subclasses GtkWidget
 * and creates a widget which is just a button. 
 *
 * Requires: glib >= 2.44, gtk4 >= 4.0.0 
 *
 * This is a template for a FINAL (as opposed to DERIVABLE gobject type.
 * Final types are simpler. You do most of the work in the C file and just
 * expose a handful of public methods in the .h file.
 *
 * In other words, as it can't be subclassed further, you don't publicly
 * expose the guts of the object at all and it's just all defined and dealt
 * with using standard GObject/GTK functions.
 */

#include "demowidget.h"

/* INTERNAL DECLARATIONS */

/* This is not strictly necessary as we've kept things in a naturally working
 * order below. But G_DEFINE_TYPE does *not* provide declarations for these
 * destructor functions, so if you change the order of the constructors and
 * destructors defined below, you'll get an error.
 */

static void demo_widget_dispose (GObject *object);
static void demo_widget_finalize (GObject *object);

/* GOBJECT DEFINITION */

/* First, create the main struct that has the guts of the object in it.
 * Follow the format of the underscore followed by the CamelCase type
 * name that you created in the header file. The typedef is autogenerated
 * by the macros and is expected to be defined here.
 */

struct _DemoWidget
{
	/* subclass type - be sure you do *not* use a pointer. Keep this as the
	 * first member.
	 */
	GtkWidget parent_instance;

	/* Custom meat and potatoes go here.
	 * For now, we are just creating a button.
	 */
	GtkWidget *button;
};

/* once the main struct is defined as above, here is hte next macro. Make sure
 * this goes in before doing anything else. Order matters.
 *
 * First two arguments to the macro are boilerplate. The last is the standard
 * capitalized TYPE macro of *what you're subclassing.* Lowest you can go is
 * G_TYPE_OBJECT for a raw gobject. In this case we're subclassing
 * GtkWidget, so that type macro is specified below.
 */
G_DEFINE_TYPE (DemoWidget, demo_widget, GTK_TYPE_WIDGET)


/* METHOD DEFINITIONS */

/* this function is used to build the widget. Note that although the docs refer
 * to something as the 'instance_init' function, the subroutine is actually
 * named *_init and not *_instance_init. That confused me at first.
 */
static void
demo_widget_init (DemoWidget *self)
{
	GtkWidget *widget = GTK_WIDGET(self);

	self->button = gtk_button_new_with_label ("Hello, world!");
	gtk_widget_set_hexpand (self->button, TRUE);
	gtk_widget_set_parent (self->button, widget);
}

/* This is one stage of the destructor process along with _finalize.
 * Here, you more-so destruct items that are ref-counted (eg, GObject-y
 * stuff) as opposed to being independent (like a string, or a FILE *
 * pointer, which should be freed / fclosed as opposed to being unreffed).
 *
 * See also:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 */
static void
demo_widget_dispose (GObject *object)
{
	DemoWidget *self = DEMO_WIDGET(object);

	gtk_widget_unparent (GTK_WIDGET(self->button));

	/* Final step: Chain up (boilerplate)
	 *
	 * This is called `chaining up' by the gobject docs. *_parent_class
	 * is auto-generated by the macros - acc. to gtype.h, it's a static
	 * variable pointing to the parent class.
	 */
	G_OBJECT_CLASS(demo_widget_parent_class)->dispose(object);
}

/* Another stage of the destruction process. My understanding is that here,
 * you free items that are independent only; see _finalize above for more info.
 *
 * See:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for a description of the nuances between _dispose and _finalize.
 */
static void
demo_widget_finalize (GObject *gobject)
{
	/* here, you would free stuff. I've got nuthin' for ya. */

	/* --- */

	/* Always chain up to the parent class; as with dispose(), finalize() is
	 * autogenerated and thus always guaranteed to exist on the parent's class
	 * virtual function table
	 */
	
	G_OBJECT_CLASS(demo_widget_parent_class)->finalize(gobject);
}

/* this method gets run the first time the class is *ever* utilized but not
 * again.
 *
 * See:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for more info on what you need to put in this subroutine re: destructors.
 *
 * Note: I kept getting confused about what 'klass' meant and why it's spelled
 * that way. You could call it fluffy if you'd like - but it is just to avoid
 * using the token `class' on its own which is a c++ reserved word.
 */
static void
demo_widget_class_init (DemoWidgetClass *klass)
{
	GObjectClass *object_class = G_OBJECT_CLASS(klass);

	object_class->dispose = demo_widget_dispose;
	object_class->finalize = demo_widget_finalize;

	gtk_widget_class_set_layout_manager_type (GTK_WIDGET_CLASS(klass),
			GTK_TYPE_BOX_LAYOUT);
}

/* and finally, here's the actual definition of our public function to create
 * an instance of our object which is... completely boilerplate!
 *
 * There are some circumstances where this will not be boilerplate; for
 * instance, if you've subclassed GtkApplicationWindow and want to take `app`
 * as an argument during your `activate` function. You'll then want to look
 * at what types of properties the objects you've subclassed can handle, and
 * then look to the docs for g_object_new() as to how to set those in your
 * _new method.
 */
GtkWidget *
demo_widget_new (void)
{
	return g_object_new (DEMO_TYPE_WIDGET, NULL);
}
