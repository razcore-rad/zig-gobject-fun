const c = @cImport(@cInclude("demowidget.h"));

fn alignPtrCast(comptime T: type, ptr: anytype) T {
    return @ptrCast(T, @alignCast(@alignOf(T), ptr));
}

// This type corresponds to the C DemoWidget typedef struct with a few helper functions
// for canonical Zig.
pub const DemoWidget = opaque {
    const Self = @This();

    // All extern functions of interest defined in demowidgets.c.
    extern fn demo_widget_get_parent_class() *anyopaque;
    const get_parent_class = demo_widget_get_parent_class;

    extern fn demo_widget_get_button(self: *Self) *c.GtkWidget;
    const get_button = demo_widget_get_button;

    extern fn demo_widget_set_button(self: *Self, button: *c.GtkWidget) void;
    const set_button = demo_widget_set_button;

    extern fn demo_widget_new() *c.GtkWidget;
    pub const new = demo_widget_new;

    // this function is used to build the widget. Note that although the docs refer
    // to something as the 'instance_init' function, the subroutine is actually
    // named *_init and not *_instance_init. That confused me at first.
    export fn demo_widget_init(self: *Self) void {
        const self_widget = alignPtrCast(*c.GtkWidget, self);
        const optional_button = c.gtk_button_new_with_label("Hello, from Zig!");
        if (optional_button) |button| {
            self.set_button(button);
            c.gtk_widget_set_hexpand(button, @boolToInt(true));
            c.gtk_widget_set_parent(button, self_widget);
        }
    }

    // This is one stage of the destructor process along with _finalize.
    // Here, you mostly destruct items that are reference-counted (eg, GObject-y
    // stuff) as opposed to not (like a string, or a FILE * pointer, which should
    // be freed / fclosed as opposed to being unreffed).
    // It is important to remember this method may be called multiple times. It
    // is a programmer error not to account for that. If you unref a GObject that
    // already has a reference count of 0, you'll get a runtime error. See below
    // for how we account for that.
    // See Part 1B of this series for problems you can run into if you don't deal
    // with this correctly.
    // See also:
    // https://developer-old.gnome.org/gobject/stable/howto-gobject-destruction.html
    export fn demo_widget_dispose(object: *c.GObject) void {
        const self = @ptrCast(*Self, object);
        var button = self.get_button();

        //  g_clear_pointer is a very useful function. It calls a function of your
        // choice to unref or free a pointer, and then sets that pointer to NULL.
        // If it is called on a NULL pointer, it simply does nothing. That allows
        // for a perfect way to handle the issue of _dispose being called multiple
        // times.
        // Here, gtk_widget_unparent is the standard GTK function to de-couple
        // a child widget from its parent, which unrefs that widget behind the
        // scenes.
        // Note that g_clear_pointer takes a pointer *to* a gpointer, and not a
        // straight gpointer. That is necessary for the function to NULL-ify the
        // pointer.
        c.g_clear_pointer(
            @ptrCast(*?*anyopaque, &button),
            @ptrCast(c.GDestroyNotify, &c.gtk_widget_unparent),
        );

        // Final step: Chain up (boilerplate)
        // This is called `chaining up' by the gobject docs. *_parent_class
        // is auto-generated by the macros - acc. to gtype.h, it's a static
        // variable pointing to the parent class.
        if (alignPtrCast(*c.GObjectClass, demo_widget_get_parent_class()).dispose) |fDispose| {
            fDispose(object);
        }
    }
};
