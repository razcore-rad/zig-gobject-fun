/* What this is, is an extremely simple annotated .c file that implements a
 * custom widget in gtk3 with gobject. All it does is subclasses GtkBox and
 * sticks two standard GtkEntry boxes in it. It requires glib >= 2.44
 *
 * This is a template for a FINAL (as opposed to DERIVABLE gobject type.
 * Final types are simpler. You do most of the work in the C file and just
 * expose a handful of public subroutines in the .h file.
 *
 * In other words, as it can't be subclassed further, you don't publicly
 * expose the guts of the object at all and it's just all defined and dealt
 * with using standard GObject/GTK subroutines.
 */

/* First, we include our header file. See the annotations therein for more
 * information. */

#include "custom.h"

/* First, create the main struct that has the guts of the object in it.
 * It must follow this template in the tag; otherwise it won't be recognized
 * by the gobject macros.
 */

struct _DemoWidget {
	/* subclass type followed by 'parent_instance' - don't try to use
	 * another name than 'parent_instance' - it's boilerplate. */
	GtkBox parent_instance;

	/* custom meat & potatoes of the 'guts' - here our object has
	 * two GtkEntry widgets in it, so we declare them accordingly.
	 */
	GtkWidget *entry1;
	GtkWidget *entry2;
};

/* once the main struct is defined as above, here is hte next macro. Make sure
 * this goes in before doing anything else. Order matters.
 *
 * First two arguments to the macro are boilerplate. The last is the standard
 * capitalized TYPE macro of *what you're subclassing.* Lowest you can go is
 * G_TYPE_OBJECT for a raw gobject. In this case we're subclassing GtkBox, so
 * that type macro is specified below.
 */

G_DEFINE_TYPE(DemoWidget, demo_widget, GTK_TYPE_BOX)

/* this function is used to build the widget. Note that although the docs refer
 * to something as the 'instance_init' function, the subroutine is actually
 * named *_init and not *_instance_init. That confused me at first.
 */

static void demo_widget_init(DemoWidget *self) {
	self->entry1 = gtk_entry_new();
	gtk_container_add(GTK_CONTAINER(self), self->entry1);
  
	self->entry2 = gtk_entry_new();
	gtk_container_add(GTK_CONTAINER(self), self->entry2);
}

/* this is the 'destructor.' I have mostly copied this code from his example at
 * https://gitlab.gnome.org/matthiasc/guadec-2020/-/blob/master/actions.c
 * I wish I understood it better. FIXME
 *
 * From what I can see, your object will get passed into the function, and
 * you'll want to run glib-ish `free` type functions on it. Here as we have
 * defined entry1 and entry2, we need to free those.
 *
 * I believe the G_OBJECT_CLASS line at the bottom is boilerplate.
 *
 * See also:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 */

static void demo_widget_dispose(GObject *object) {
	DemoWidget *self = DEMO_WIDGET(object);

	g_clear_pointer(&self->entry1, gtk_widget_unparent);
	g_clear_pointer(&self->entry2, gtk_widget_unparent);

	/* Boilerplate.
	 * this is called `chaining up' by the gobject docs. *_parent_class
	 * is auto-generated by the macros - acc. to gtype.h, it's a static
	 * variable pointing to the parent class.
	 */

	G_OBJECT_CLASS(demo_widget_parent_class)->dispose(object);
}

/* another stage of the destruction process. My understanding is that here,
 * you free items that are independent only; for things that have a reference to
 * 'self', you use dispose.
 *
 * See:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for a description of the nuances.
 */

static void demo_widget_finalize(GObject *gobject) {
	/* here, you would free stuff. I've got nuthin' for ya. */

	/* --- */

	/* Always chain up to the parent class; as with dispose(), finalize() is
	 * autogenerated and thus always guaranteed to exist on the parent's class
	 * virtual function table
	 */
	
	G_OBJECT_CLASS(demo_widget_parent_class)->finalize(gobject);
}

/* this subroutine gets run the first time the class is *ever* utilized but not
 * again. It seems to be needed to actually tell gobject what the class's
 * destructor functions are. mclasen's sample code above does more things. Not
 * quite sure about it, really.
 *
 * See:
 * https://developer.gnome.org/gobject/stable/howto-gobject-destruction.html
 * for more info on what you need to put in this subroutine re: destructors.
 *
 * Note: I kept getting confused about what 'klass' meant and why it's spelled
 * that way. You could call it fluffy if you'd like - but it is just to avoid
 * using the token `class' on its own which is a c++ reserved word.
 */

static void demo_widget_class_init(DemoWidgetClass *klass) {
	GObjectClass *object_class = G_OBJECT_CLASS(klass);

	object_class->dispose = demo_widget_dispose;
	object_class->finalize = demo_widget_finalize;
}

/* and finally, here's the actual definition of our public function to create
 * an instance of our object which is... completely boilerplate!
 */

GtkWidget *demo_widget_new(void) {
	return g_object_new(DEMO_TYPE_WIDGET, NULL);
}
